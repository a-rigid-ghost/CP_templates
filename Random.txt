/////greedy sweepline implementation style
///// initial positions a[], cost to move per unit t[]
/////find min cost so that all are finally at distinct positions

void solve(){
    lli n;
    cin>>n;
    lli a[n+1],t[n+1];
    fr(i,1,n+1)cin>>a[i];
    fr(i,1,n+1)cin>>t[i];
    map<lli,ve> m;
    multiset<pll,greater<pll>> s;
    fr(i,1,n+1){
        m[a[i]].pb(t[i]);
    }
    auto nxt=m.begin();
    lli ans=0;
    while(nxt!=m.end()){
        auto cur=nxt++;
        for(auto e:cur->S){
            s.insert(mp(e,cur->F));
        }
        lli sz=s.size();
        if(nxt!=m.end())sz=min(sz,nxt->F-cur->F);
        fr(i,0,sz){
            auto temp=s.begin();
            ans+=(temp->F*((cur->F+i)-temp->S));
            s.erase(s.begin());
        }
    }
    cout<<ans;
}

/////GRID BFS 

lli n,m,w;
ve dr={1,-1,0,0};
ve dc={0,0,1,-1};

lli check(lli i,lli j){
    if(i>0 && i<=n && j>0 && j<=m)return 1;
    return 0;
}

vector<ve> bfs(lli x,lli y){
    vector<ve> dist(n+5,ve(m+5,-1));
    queue<pll> q;
    dist[x][y]=0;
    q.push(mp(x,y));
    while(!q.empty()){
        pll cur=q.front();
        q.pop();
        fr(i,0,4){
            lli r=cur.F+dr[i],c=cur.S+dc[i];
            if(check(r,c) && dist[r][c]==-1){
                dist[r][c]=dist[cur.F][cur.S]+1;
                q.push(mp(r,c));
            }
        }
    }
    return dist;
}
